<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://eliasdaler.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=alternate type=application/rss+xml href=https://eliasdaler.github.io/feed.xml title="Elias Daler's blog"><title>Making and storing references to game objects (entities) in C++ and Lua</title></head><body><header id=banner><h2><a href=https://eliasdaler.github.io>Elias Daler's blog</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>Making and storing references to game objects (entities) in C++ and Lua</h1><div>Publication date: <time>January 22, 2017</time></div><div></div></header><div><h2>Table Of Contents</h2><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#shared_ptr-and-weak_ptr>shared_ptr and weak_ptr</a></li><li><a href=#using-unique-ids>Using unique ids</a></li><li><a href=#storing-references-to-entities-in-lua>Storing references to entities in Lua</a></li></ul></nav></div><h2 id=introduction>Introduction</h2><figure><img src=ids.png></figure><p>The problem of handling references to game objects (I&rsquo;ll call them <em>entities</em>) comes up very often. Sometimes it&rsquo;s child-parent relationship between the entities, sometimes it&rsquo;s useful to store a reference to an object in event data, some task scheduling class and so on.</p><p>Sometimes a simple pointer, reference or <code>std::reference_wrapper</code> is enough. But the problem with raw pointers and references is that once you use them, you have to make sure that the entity which is being referenced stays alive and is not moved in memory without notifying objects which hold references. And with good design you&rsquo;ll probably be able to achieve that.</p><p>But stale pointers/references give some of the worst bugs, which are difficult to track, crash your game and may not be easily identifiable. Some entities may start to occupy different addresses in memory (for example, after you reload a level and decide to create all entities from scratch). While it&rsquo;s possible to manually update all pointers to previously referenced entities, it&rsquo;s certainly will be better to do so automatically and without a chance of forgetting some pointers which will be stale.</p><p>Let&rsquo;s see all these problems can be solved. The latest solution (about storing references to Lua) was discovered by me not long ago and it is the point of me writing the article, but I want to show some other ways of solving the problem. Let&rsquo;s start!</p><h2 id=shared_ptr-and-weak_ptr>shared_ptr and weak_ptr</h2><p>Some of the problems with raw references can be solved with <code>std::shared_ptr</code> and <code>std::weak_ptr</code>. First, you create your entities as with <code>std::make_shared</code>. After that you&rsquo;ll create all references to it with <code>std::weak_ptr</code>s which won&rsquo;t affect your entity&rsquo;s lifetime. After that you can use <code>std::weak_ptr&lt;T>::expired</code> function to check if the reference is still valid.</p><p>The solution is not perfect. First of all, it requires you to create all your entities as <code>shared_ptr</code>s which may have some significant overhead compared to <code>unique_ptr</code>s. And after all, it&rsquo;s better for the lifetime of entities not to be shared and that semantic is better expressed with <code>unique_ptr</code>. Shared pointers also don&rsquo;t solve the problem of moving entities in memory: you can&rsquo;t swap what&rsquo;s inside the <code>shared_ptr</code> and have all <code>weak_ptr</code>s automatically update their pointers.</p><h2 id=using-unique-ids>Using unique ids</h2><p>One solution to the problem is just creating unique ids for entities and storing those ids instead of raw pointers or references. There a lots of ways to generate and represent entity ids. Ids can just be integers with <code>EntityManager</code> having a counter which will be incremented as new entities are created: the first entity will get id=0, the second one id=1 and so on. Another way to generate ids is to use some hashing algorithm or <a href=https://en.wikipedia.org/wiki/Universally_unique_identifier>UUID</a>s. No matter what, your ids should stay unique, unless you add some additional info (like entity creation time or some tags) to your id.</p><p>Here&rsquo;s how your <code>EntityManager</code> class may look:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=font-weight:700>class</span> <span style=color:#458;font-weight:700>EntityManager</span> {
</span></span><span style=display:flex><span><span style=font-weight:700>public</span><span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>    Entity<span style=font-weight:700>*</span> getEntity(EntityId id) <span style=font-weight:700>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>bool</span> <span style=color:#900;font-weight:700>entityExists</span>(EntityId id) <span style=font-weight:700>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=font-weight:700>private</span><span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>    std<span style=font-weight:700>::</span>unordered_map<span style=font-weight:700>&lt;</span>EntityId, std<span style=font-weight:700>::</span>unique_ptr<span style=font-weight:700>&lt;</span>Entity<span style=font-weight:700>&gt;&gt;</span> entities;
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>};
</span></span></code></pre></div><p>Using ids also helps with recreation problem: you can easily reload/recreate the entity and just assign the same id to it as before. It will have a different adress in memory, but the next time someone calls <code>getEntity</code> the updated entity is returned. You can also easily send these ids over the network or save them in your save files.</p><p>Your code when using entity id becomes something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=font-weight:700>auto</span> entityPtr <span style=font-weight:700>=</span> g_EntityManager.getEntity(entityId);
</span></span><span style=display:flex><span>entityPtr<span style=font-weight:700>-&gt;</span>doSomething();
</span></span></code></pre></div><p>Of course this creates some overhead because you now have a layer of indirection: you have to search <code>unordered_map</code> inside the <code>EntityManager</code> to get the raw reference to the entity, but if you don&rsquo;t do it too often (and you most likely won&rsquo;t), you&rsquo;ll be fine!</p><p>There&rsquo;s another improvement which can be done: you can wrap your id inside the struct and then overload <code>operator-></code> for handle to act like a raw pointer:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=font-weight:700>struct</span> <span style=color:#458;font-weight:700>EntityHandle</span> {
</span></span><span style=display:flex><span>    EntityId id;
</span></span><span style=display:flex><span>    EntityManager<span style=font-weight:700>*</span> entityManager;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    EntityHandle(EntityId id, EntityManager<span style=font-weight:700>*</span> entityManager) <span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>        id(id), entityManager(entityManager)
</span></span><span style=display:flex><span>    {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Entity<span style=font-weight:700>*</span> <span style=font-weight:700>operator</span><span style=font-weight:700>-&gt;</span>() <span style=font-weight:700>const</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> <span style=color:#900;font-weight:700>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Entity<span style=font-weight:700>*</span> <span style=color:#900;font-weight:700>get</span>() <span style=font-weight:700>const</span> {
</span></span><span style=display:flex><span>        assert(entityManager<span style=font-weight:700>-&gt;</span>entityExists(id));
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> entityManager<span style=font-weight:700>-&gt;</span>getEntity(id);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Now you can do things like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>EntityHandle <span style=color:#900;font-weight:700>handle</span>(someEntityId, <span style=font-weight:700>&amp;</span>g_EntityManager);
</span></span><span style=display:flex><span>handle<span style=font-weight:700>-&gt;</span>doSomething();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// or...
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=font-weight:700>auto</span> entityPtr <span style=font-weight:700>=</span> handle.get();
</span></span><span style=display:flex><span>entityPtr<span style=font-weight:700>-&gt;</span>doSomething();
</span></span></code></pre></div><p>Notice that we also get some error checking with assert which checks validity of the reference.
Great! Now let&rsquo;s see how we can reference entities in Lua scripts.</p><h2 id=storing-references-to-entities-in-lua>Storing references to entities in Lua</h2><blockquote class=hint-info>Full implementation can be found here: <a href=https://gist.github.com/eliasdaler/f5c2ee50fc7e42bf3ee18ad7d46d18f8>C++ part</a>, <a href=https://gist.github.com/eliasdaler/f3516d3deabc32b465a7c244ff082cf0>Lua part</a>.</blockquote><p>First of all, it&rsquo;s obvious that you can use the same approach in Lua. Your handle can just be a number or a table with <code>__index</code> meta-method so that you can use your handle as if it was the raw reference. But there&rsquo;s a neater method I recently came up with. Let&rsquo;s see how it works.</p><p>First of all, our handles will be tables with raw C++ references stored in them as userdata. They&rsquo;ll also have a bool named <code>isValid</code> which will help us test if the handle is still valid. We&rsquo;ll also have a global table of references in Lua, so that you can easily get handle from any place without calling C++. What&rsquo;s neat is that you&rsquo;ll get <strong>references</strong> to your handles, not a copy. It&rsquo;s great, because you can easily compare two handles or even use them as table keys. You also don&rsquo;t waste your memory, but that&rsquo;s not a big concern as our handles are very light.</p><p>If you want to remove and recreate some entity, you&rsquo;ll just have to notify the main Lua handle which will be stored inside some global Lua table. And because all your handles in Lua will be references to original handle you won&rsquo;t have to care about them: once you update the main handle, it&rsquo;s updated everywhere.</p><p>Another good thing is that once the entity is removed, we can just set <code>isValid</code> to <code>false</code> and raw reference to <code>nil</code> just to be extra safe.</p><p>Let&rsquo;s get to implementation! We&rsquo;ll use <a href=https://github.com/ThePhD/sol2>sol2</a> as our Lua/C++ binding library. Let&rsquo;s write a simple <code>Entity</code> and <code>EntityManager</code> classes for testing:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=font-weight:700>using</span> EntityId <span style=font-weight:700>=</span> <span style=color:#458;font-weight:700>int</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>class</span> <span style=color:#458;font-weight:700>Entity</span> {
</span></span><span style=display:flex><span><span style=font-weight:700>public</span><span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>explicit</span> Entity(EntityId id) <span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>        name(<span style=color:#b84>&#34;John&#34;</span>), id(id)
</span></span><span style=display:flex><span>    {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>const</span> std<span style=font-weight:700>::</span>string<span style=font-weight:700>&amp;</span> getName() <span style=font-weight:700>const</span> { <span style=font-weight:700>return</span> name; }
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>setName</span>(<span style=font-weight:700>const</span> std<span style=font-weight:700>::</span>string<span style=font-weight:700>&amp;</span> n) { name <span style=font-weight:700>=</span> n; }
</span></span><span style=display:flex><span>    EntityId <span style=color:#900;font-weight:700>getId</span>() <span style=font-weight:700>const</span> { <span style=font-weight:700>return</span> id; }
</span></span><span style=display:flex><span><span style=font-weight:700>private</span><span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>    std<span style=font-weight:700>::</span>string name;
</span></span><span style=display:flex><span>    EntityId id;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sol<span style=font-weight:700>::</span>state lua; <span style=color:#998;font-style:italic>// globals are bad, but we&#39;ll use it for simpler implementation
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=font-weight:700>class</span> <span style=color:#458;font-weight:700>EntityManager</span> {
</span></span><span style=display:flex><span><span style=font-weight:700>public</span><span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>    EntityManager() <span style=font-weight:700>:</span> idCounter(<span style=color:#099>0</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Entity<span style=font-weight:700>&amp;</span> createEntity()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>auto</span> id <span style=font-weight:700>=</span> idCounter;
</span></span><span style=display:flex><span>        <span style=font-weight:700>++</span>idCounter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>auto</span> inserted <span style=font-weight:700>=</span> entities.emplace(id, std<span style=font-weight:700>::</span>make_unique<span style=font-weight:700>&lt;</span>Entity<span style=font-weight:700>&gt;</span>(id));
</span></span><span style=display:flex><span>        <span style=font-weight:700>auto</span> it <span style=font-weight:700>=</span> inserted.first; <span style=color:#998;font-style:italic>// iterator to created id/Entity pair
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        <span style=font-weight:700>auto</span><span style=font-weight:700>&amp;</span> e <span style=font-weight:700>=</span> <span style=font-weight:700>*</span>it<span style=font-weight:700>-&gt;</span>second; <span style=color:#998;font-style:italic>// created entity
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        lua[<span style=color:#b84>&#34;createHandle&#34;</span>](e);
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> e;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>removeEntity</span>(EntityId id)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        lua[<span style=color:#b84>&#34;onEntityRemoved&#34;</span>](id);
</span></span><span style=display:flex><span>        entities.erase(id);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=font-weight:700>private</span><span style=font-weight:700>:</span>
</span></span><span style=display:flex><span>    std<span style=font-weight:700>::</span>unordered_map<span style=font-weight:700>&lt;</span>EntityId, std<span style=font-weight:700>::</span>unique_ptr<span style=font-weight:700>&lt;</span>Entity<span style=font-weight:700>&gt;&gt;</span> entities;
</span></span><span style=display:flex><span>    EntityId idCounter;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Here&rsquo;s how we will create our handle in Lua:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>createHandle</span>(cppRef)
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> handle <span style=font-weight:700>=</span> {
</span></span><span style=display:flex><span>        cppRef <span style=font-weight:700>=</span> cppRef,
</span></span><span style=display:flex><span>        isValid <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    setmetatable(handle, mt)
</span></span><span style=display:flex><span>    Handles[cppRef:getId()] <span style=font-weight:700>=</span> handle
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> handle
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>The <code>Handles</code> global table stores all handles so that we can easily get them later. As you can see, we still use integer ids for it as a tables key so that when we remove an entity, we can easily find its handle and modify it appropriately.</p><p>The metatable has an important function: it will let us use the handle as if it was the original reference. Here&rsquo;s how it&rsquo;s written:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> mt <span style=font-weight:700>=</span> { }
</span></span><span style=display:flex><span>mt.__index <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(handle, key)
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> handle.isValid <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>        print(debug.traceback())
</span></span><span style=display:flex><span>        error(<span style=color:#b84>&#34;Error: handle is not valid!&#34;</span>, <span style=color:#099>2</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=font-weight:700>function</span>(handle, ...) <span style=font-weight:700>return</span> Entity[key](handle.cppRef, ...) <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Just a quick reminder: metatable&rsquo;s <code>__index</code> function gets called when the key in the table is not found and the table (our handle) and missing key are passed.</p><p>Here&rsquo;s an example of how it all works. When we do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>handle:setName(<span style=color:#b84>&#34;John&#34;</span>)
</span></span></code></pre></div><p>Lua checks if handle table has &ldquo;setName&rdquo; key, but it doesn&rsquo;t, so it calls metatable&rsquo;s <code>__index</code> function with handle and &ldquo;John&rdquo; as parameters. The wrapper around <code>Entity</code>&rsquo;s member function is returned and it gets called. The function which gets returned is a closure which calls the <code>Entity</code>&rsquo;s class member function on original raw reference. Why can&rsquo;t we just return <code>Entity[key]</code>? The problem with that is that our handle will get passed into it while the function expects raw reference to be passed (<code>cppRef:setName("John")</code> is the same as calling <code>Entity.setName(cppRef, "John")</code>).</p><p>The error checking that we have here is extremely important and useful! It allows us to easily debug problems with our code: we even print the call stack to find the place where our code crashed!</p><blockquote class=hint-info>Notice that we pass &ldquo;2&rdquo; as the second argument in <code>error</code> function. It tells it that the problem is not the function which called it, the bad one was below it in a call stack.</blockquote><p>Another great thing about this implementation is that it lets us handle error on Lua side, not C++ side. Once the C++ function is called from Lua, it&rsquo;s hard to properly throw and catch an error from C++. You&rsquo;ll have to compile Lua as C++ to do it without a crash. Throwing the error before calling C++ allows us to safely catch it on Lua side and handle it appropriately. We&rsquo;ll see how it can be done a bit later.</p><p>Let&rsquo;s test out reference first:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>test</span>(cppRef)
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> handle <span style=font-weight:700>=</span> createHandle(cppRef)
</span></span><span style=display:flex><span>    testHandle(handle)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>testHandle</span>(handle)
</span></span><span style=display:flex><span>    print(<span style=color:#b84>&#34;Hello, my name is &#34;</span> <span style=font-weight:700>..</span> handle:getName())
</span></span><span style=display:flex><span>    handle:setName(<span style=color:#b84>&#34;Mark&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#b84>&#34;My name is &#34;</span> <span style=font-weight:700>..</span> handle:getName() <span style=font-weight:700>..</span> <span style=color:#b84>&#34; now!&#34;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Output:</p><p>It works! What should we do when entity gets removed? Let&rsquo;s create a function for that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>onEntityRemoved</span>(id)
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> handle <span style=font-weight:700>=</span> Handles[id];
</span></span><span style=display:flex><span>    handle.cppRef <span style=font-weight:700>=</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>    handle.isValid <span style=font-weight:700>=</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>    Handles[id] <span style=font-weight:700>=</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>We need to call it before our entity gets removed and you can place it into <code>Entity</code>&rsquo;s destructor or into <code>EntityManager</code>&rsquo;s <code>removeEntity</code> function. Note, that this doesn&rsquo;t remove the handle itself: someone may still be referencing it, but setting corresponding value in <code>Handles</code> table to <code>nil</code> is still useful because if someone tries to grab a handle later, <code>nil</code> will be returned. What&rsquo;s more important is that <code>isValid</code> is set to false so that the next time someone tries to use the handle, the error will be raised.</p><p>Now let&rsquo;s see what happens when we try to use invalid reference. We can even do our error handling in Lua now!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>testBadReference</span>()
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> handle <span style=font-weight:700>=</span> Handles[<span style=color:#099>0</span>] <span style=color:#998;font-style:italic>-- this handle exists and is okay</span>
</span></span><span style=display:flex><span>    handle.isValid <span style=font-weight:700>=</span> <span style=font-weight:700>false</span> <span style=color:#998;font-style:italic>-- but suppose that entity was removed!</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> _, err <span style=font-weight:700>=</span> pcall(testHandle, handle)
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> err <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>        print(err)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>When we call this function from C++ we don&rsquo;t get a crash which would have been caused by using stale reference. Instead, we get a helpful error message and call stack:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>stack traceback:
</span></span><span style=display:flex><span>    script.lua:23: in <span style=font-weight:700>function</span> <span style=color:#b84>&#39;getName&#39;</span>
</span></span><span style=display:flex><span>    script.lua:57: in <span style=font-weight:700>function</span> &lt;script.lua:56&gt;
</span></span><span style=display:flex><span>    <span style=font-weight:700>[</span>C<span style=font-weight:700>]</span>: in <span style=font-weight:700>function</span> <span style=color:#b84>&#39;pcall&#39;</span>
</span></span><span style=display:flex><span>    script.lua:65: in <span style=font-weight:700>function</span> &lt;script.lua:62&gt;
</span></span><span style=display:flex><span>script.lua:57: Error: handle is not valid!
</span></span></code></pre></div><p>What about the performance? My tests show that it&rsquo;s around <strong>600 nanoseconds</strong> per C++ member function call. It&rsquo;s not that bad, but still may be not good enough for some people. In that case it&rsquo;s easy to get a raw reference and then use it without any additional overhead of error checking:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> rawRef <span style=font-weight:700>=</span> handle.cppRef
</span></span><span style=display:flex><span>print(<span style=color:#b84>&#34;Raw reference used. Name: &#34;</span> <span style=font-weight:700>..</span> rawRef:getName())
</span></span></code></pre></div><p>We can also speed up <code>__index</code> function. I&rsquo;ve found that its biggest overhead is creating a closure every time&mldr; so let&rsquo;s memoize our wrapper functions! First of all, we&rsquo;ll create a table which will store our wrapper functions:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> memoizedFuncs <span style=font-weight:700>=</span> {}
</span></span></code></pre></div><p>And then we change our <code>__index</code> method to this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>mt.__index <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(handle, key)
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> handle.isValid <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>        print(debug.traceback())
</span></span><span style=display:flex><span>        error(<span style=color:#b84>&#34;Error: handle is not valid!&#34;</span>, <span style=color:#099>2</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> f <span style=font-weight:700>=</span> memoizedFuncs[key]
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> f <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>        f <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(handle, ...) <span style=font-weight:700>return</span> Entity[key](handle.cppRef, ...) <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>        memoizedFuncs[key] <span style=font-weight:700>=</span> f
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> f
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>The closure for each function will be created once and then will get reused. This speeds up things considerably! The overhead is roughly <strong>200 nanoseconds</strong> per call.</p><p>What else? Calling the function through <code>__index</code> produces additional overhead too. Suppose that we use <code>getName</code> function very often and want it to be part of our handle table so that it&rsquo;s called directly. Ok, let&rsquo;s do this!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>createHandle</span>(cppRef)
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> handle <span style=font-weight:700>=</span> {
</span></span><span style=display:flex><span>        cppRef <span style=font-weight:700>=</span> cppRef,
</span></span><span style=display:flex><span>        isValid <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    handle.getName <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(handle, ...)
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> Entity.getName(handle.cppRef, ...)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    setmetatable(handle, mt)
</span></span><span style=display:flex><span>    Handles[cppRef:getId()] <span style=font-weight:700>=</span> handle
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> handle
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Wait a second&mldr; what happens when we call getName on bad handle? There&rsquo;s no error checking! Let&rsquo;s fix that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>getWrappedSafeFunction</span>(f)
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=font-weight:700>function</span>(handle, ...)
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> handle.isValid <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>                print(debug.traceback())
</span></span><span style=display:flex><span>                error(<span style=color:#b84>&#34;Error: handle is not valid!&#34;</span>, <span style=color:#099>2</span>)
</span></span><span style=display:flex><span>            <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> f(handle.cppRef, ...)
</span></span><span style=display:flex><span>        <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>and then in createHandle we&rsquo;ll write:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>handle.getName <span style=font-weight:700>=</span> getWrappedSafeFunction(Entity.getName)
</span></span></code></pre></div><p>Now the overhead is just <strong>70 nanoseconds</strong>. The only added overhead is additional function call, validity check and retrieval of raw reference from handle table, but I think it&rsquo;s pretty small for gained benefits.</p></article></main><footer id=footer>Â© 2022 Elias Daler. All rights reserved.<p>subscribe via <a href=https://eliasdaler.github.io/feed.xml>RSS</a></p></footer></body></html>